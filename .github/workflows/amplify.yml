name: Amplify
permissions:
  contents: read

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  amplify:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
      - name: Amplify Runner
        uses: amplify-security/runner-action@v0.4.0
            - name
  uses:  unexpected "value"
  with:
    # Set always-auth in npmrc.
   always-auth: # optional, default is false
    # Version Spec of the version to use. Examples: 12.x, 10.15.1, >=10.15.0.
    node-version: # optional
    # File containing the version Spec of the version to use.  Examples: package.json, .nvmrc, .node-version, .tool-versions.
    node-version-file: # optional
    # Target architecture for Node to use. Examples: x86, x64. Will use system architecture by default.
    architecture: # optional
    # Set this option if you want the action to check for the latest available version that satisfies the version spec.
    check-latest: # optional
    # Optional registry to set up for auth. Will set the registry in a project level .npmrc and .yarnrc file, and set up auth to read in from env.NODE_AUTH_TOKEN.
    registry-url: # optional
    # Optional scope for authenticating against scoped registries. Will fall back to the repository owner when using the GitHub Packages registry (https://npm.pkg.github.com/).
    scope: # optional
    # Used to pull node distributions from node-versions. Since there's a default, this is typically not supplied by the user. When running this action on github.com, the default value is sufficient. When running on GHES, you can pass a personal access token for github.com if you are experiencing rate limiting.
    token: # optional, default is ${{ github.server_url == 'https://github.com' && github.token || '' }}
    # Used to specify a package manager for caching in the default directory. Supported values: npm, yarn, pnpm.
    cache: # optional
    # Set to false to disable automatic caching. By default, caching is enabled when either devEngines.packageManager or the top-level packageManager field in package.json specifies npm as the package manager.
    package-manager-cache: # optional, default is true
    # Used to specify the path to a dependency file: package-lock.json, yarn.lock, etc. Supports wildcards or a list of file names for caching multiple dependencies.
    cache-dependency-path: unexpected value
    # Used to specify an alternative mirror to downlooad Node.js binaries from
    mirror: # optional
    # The token used as Authorization header when fetching from the mirror
    mirror-token: # optional
                      - name: Download a Build Artifact
  uses: actions/download-artifact@v6.0.0
  with:
    # Name of the artifact to download. If unspecified, all artifacts for the run are downloaded.
    name: # optional
    # IDs of the artifacts to download, comma-separated. Either inputs `artifact-ids` or `name` can be used, but not both.
    artifact-ids: # optional
    # Destination path. Supports basic tilde expansion. Defaults to $GITHUB_WORKSPACE
    path: # optional
    # A glob pattern matching the artifacts that should be downloaded. Ignored if name is specified.
    pattern: # optional
    # When multiple artifacts are matched, this changes the behavior of the destination directories. If true, the downloaded artifacts will be in the same directory specified by path. If false, the downloaded artifacts will be extracted into individual named directories within the specified path.
    merge-multiple: # optional, default is false
    # The GitHub token used to authenticate with the GitHub API. This is required when downloading artifacts from a different repository or from a different workflow run. If this is not specified, the action will attempt to download artifacts from the current repository and the current workflow run.
    github-token: ${{ secrets.GITHUB_TOKEN }}
    # The repository owner and the repository name joined together by "/". If github-token is specified, this is the repository that artifacts will be downloaded from.
    repository: # optional, default is ${{ github.repository }}
    # The id of the workflow run where the desired download artifact was uploaded from. If github-token is specified, this is the run that artifacts will be downloaded from.
    run-id: # optional, default is ${{ github.run_id }}
    # A list of files, directories, and wildcard patterns to cache and restore
    path: 
    # An explicit key for restoring and saving the cache
    key: 
    # An ordered multiline string listing the prefix-matched keys, that are used for restoring stale cache if no cache hit occurred for key. Note `cache-hit` returns false in this case.
    restore-keys: # optional
    # The chunk size used to split up large files during upload, in bytes
    upload-chunk-size: # optional
    # An optional boolean when enabled, allows windows runners to save or restore caches that can be restored or saved respectively on other platforms
    enableCrossOsArchive: # optional, default is false
    # Fail the workflow if cache entry is not found
    fail-on-cache-miss: # optional, default is false
    # Check if a cache entry exists for the given input(s) (key, restore-keys) without downloading the cache
    lookup-only: # optional, default is false
    # Run the post step to save the cache even if another step before fails
    save-always: # optional, default is false
                  - name: Deploy GitHub Runner to AWS (EC2)
  # You may pin to the exact commit or the version.
  # uses: bitovi/github-actions-deploy-github-runner-to-ec2@6e35bdc2c305bec7608655b84227b88ac75c5961
  uses: bitovi/github-actions-deploy-github-runner-to-ec2@v0
  with:
    # Specifies if this action should checkout the code
    checkout: # optional, default is true
    # Will run only the generation phase of BitOps, where the Terraform and Ansible code is built.
    bitops_code_only: # optional
    # Store BitOps code as a GitHub artifact
    bitops_code_store: # optional
    # Repo URL for the runner to listen to
    repo_url: 
    # Repo access token
    repo_access_token: 
    # AWS access key ID
    aws_access_key_id: # optional
    # AWS secret access key
    aws_secret_access_key: # optional
    # AWS session token
    aws_session_token: # optional
    # AWS default region
    aws_default_region: # optional, default is us-east-1
    # Set to override the AWS resource identifier for the deployment.  Defaults to `${org}-{repo}-{branch}`.  Use with destroy to destroy specific resources.
    aws_resource_identifier: # optional
    # A JSON object of additional tags that will be included on created resources. Example: `{"key1": "value1", "key2": "value2"}`
    aws_additional_tags: # optional
    # Set to "true" to Destroy the stack through Terraform.
    tf_stack_destroy: # optional
    # Change this to be anything you want to. Carefull to be consistent here. A missing file could trigger recreation, or stepping over destruction of non-defined objects.
    tf_state_file_name: # optional
    # Append a string to the tf-state-file. Setting this to `unique` will generate `tf-state-aws-unique`. Can co-exist with the tf_state_file_name variable. 
    tf_state_file_name_append: # optional
    # AWS S3 bucket to use for Terraform state. Defaults to `${org}-${repo}-{branch}-tf-state`
    tf_state_bucket: # optional
    # Force purge and deletion of S3 bucket defined. Any file contained there will be destroyed. `tf_stack_destroy` must also be `true`
    tf_state_bucket_destroy: # optional
    # Secret name to pull env variables from AWS Secret Manager, could be a comma separated list, read in order. Expected JSON content.
    env_aws_secret: # optional
    # File containing environment variables to be used with the app
    env_repo: # optional
    # `.env` file to be used with the app from Github secrets
    env_ghs: # optional
    # `.env` file to be used with the app from Github variables
    env_ghv: # optional
    # Define if an EC2 instance should be created
    aws_ec2_instance_create: # optional
    # AWS AMI Filter string. Will be used to lookup for lates image based on the string. Defaults to `ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-amd64-server-*`.
    aws_ec2_ami_filter: # optional
    # Owner of AWS AMI image. This ensures the provider is the one we are looking for. Defaults to `099720109477`, Canonical (Ubuntu).
    aws_ec2_ami_owner: # optional
    # AWS AMI ID. Will default to lookup for latest image of the `aws_ec2_ami_filter` string. This will override `aws_ec2_ami_filter` lookup.
    aws_ec2_ami_id: # optional
    # Set this to true if you want to recreate the EC2 instance if there is a newer version of the AMI.
    aws_ec2_ami_update: # optional
    # The AWS IAM instance profile to use for the EC2 instance
    aws_ec2_iam_instance_profile: # optional
    # The AWS Instance type
    aws_ec2_instance_type: # optional
    # Define the volume size (in GiB) for the root volume on the AWS Instance.
    aws_ec2_instance_root_vol_size: # optional
    # Set this to true to avoid deletion of root volume on termination. Defaults to false.
    aws_ec2_instance_root_vol_preserve: # optional
    # The name of the EC2 security group
    aws_ec2_security_group_name: # optional
    # Generates and manages a secret manager entry that contains the public and private keys created for the ec2 instance.
    aws_ec2_create_keypair_sm: # optional
    # Add a public IP to the instance or not. (Not an Elastic IP)
    aws_ec2_instance_public_ip: # optional
    # List of ports to be enabled as an ingress rule in the EC2 SG, in a [xx,yy] format - Not the ELB
    aws_ec2_port_list: # optional
    # Relative path in the repo for a user provided script to be executed with Terraform EC2 Instance creation.
    aws_ec2_user_data_file: # optional, default is no-file-provided
    # If user_data file changes, instance will stop and start. Hence public IP will change. Defaults to true.
    aws_ec2_user_data_replace_on_change: # optional
    # A JSON object of additional tags that will be included on created resources. Example: `{"key1": "value1", "key2": "value2"}`
    aws_ec2_additional_tags: # optional
    # Define if a VPC should be created
    aws_vpc_create: # optional
    # Set a specific name for the VPC
    aws_vpc_name: # optional
    # Define Base CIDR block which is divided into subnet CIDR blocks. Defaults to 10.0.0.0/16.
    aws_vpc_cidr_block: # optional
    # Comma separated list of public subnets. Defaults to 10.10.110.0/24
    aws_vpc_public_subnets: # optional
    # Comma separated list of private subnets. If none, none will be created.
    aws_vpc_private_subnets: # optional
    # Comma separated list of availability zones. Defaults to `aws_default_region.
    aws_vpc_availability_zones: # optional
    # AWS VPC ID. Accepts `vpc-###` values.
    aws_vpc_id: # optional
    # Specify a Subnet to be used with the instance. If none provided, will pick one.
    aws_vpc_subnet_id: # optional
    # Enables NAT gateway
    aws_vpc_enable_nat_gateway: # optional
    # Creates only one NAT gateway
    aws_vpc_single_nat_gateway: # optional
    # Comma separated list of IP IDS to reuse in the NAT gateways
    aws_vpc_external_nat_ip_ids: # optional
    # A JSON object of additional tags that will be included on created resources. Example: `{"key1": "value1", "key2": "value2"}`
    aws_vpc_additional_tags: # optional
    # 
    aws_secret_env: # optional
    # 
    repo_env: # optional
    # 
    dot_env: # optional
    # 
    ghv_env: # optional
    # 
    stack_destroy: # optional
    # 
    additional_tags: # optional
    # 
    ec2_instance_profile: # optional
    # 
    ec2_instance_type: # optional
    # 
    ec2_ami_id: # optional
    # 
    ec2_ami_update: # optional
    # 
    ec2_volume_size: # optional
    # 
    ec2_root_preserve: # optional
    # 
    ec2_security_group_name: # optional
    # 
    ec2_create_keypair_sm: # optional
    # 
    ec2_instance_public_ip: # optional
    # 
    ec2_user_data_file: # optional, default is no-file-provided
    # 
    ec2_user_data_replace_on_change: # optional
    # 
    ec2_additional_tags: # optional
                
